#!/bin/bash
# sudo apt install -y ifupdown

# Step 1: Create the iptables
aEthernet="enx0c37961223a6" # the Ethernet output I want for magicJack
aWireless="wlp1s0" # the functioning wireless input
aNext=192.168.2 # the next subnet after 192.168.1
aIp_address="$aNext.1" # use the next subnet to create internal network
aNetmask="255.255.255.0" # the network mask
# aNetwork="$aNext.0" # the external inet representing the internal block
# aBroadcast="$aNext.255" # the broadcast IP
aDhcp_range_start="$aNext.50" # inet addresses to be available in subnet
aDhcp_range_end="$aNext.100" # inet addresses to be available in subnet
aDhcp_time="12h" # address lease duration

sudo ifup --all
sudo ifup ${aWireless} 2>&1 | grep -Ee "^Listening on" -e "^DHCPDISCOVER" -e "^bound to"
if [[ $(ip link show $aWireless) = *' state DOWN '* ]]; then
    echo "$(tput setaf 1)!!! $(basename "$0"): Could not ifup wlNet !!!$(tput sgr0)"
  exit
fi


sudo iptables --flush
sudo iptables -F
sudo iptables -A FORWARD -i $aWireless -o $aEthernet -m state --state RELATED,ESTABLISHED,UNTRACKED -j ACCEPT
sudo iptables -A FORWARD -i $aEthernet -o $aWireless -j ACCEPT
sudo iptables -t nat -F
sudo iptables -t nat -A POSTROUTING -o $aWireless -j MASQUERADE

# Step 2: Turn on IP forwarding.
sudo sh -c "echo 1 > /proc/sys/net/ipv4/ip_forward"
sudo ifconfig $aEthernet $aIp_address netmask $aNetmask
# May also have to uncomment net.ipv4.ip_forward=1 in /etc/sysctl.conf
# Remove possible default route created by dhcpcd.
# Hide error if route does not exist.
sudo ip route del 0/0 dev $aEthernet &> /dev/null

# Step 3: Reconfigure and restart domain name masquerade.
sudo systemctl stop dnsmasq
cat - > /tmp/custom-dnsmasq.conf <<-EOF
interface=$aEthernet
bind-interfaces
server=1.1.1.1
domain-needed
bogus-priv
dhcp-range=$aDhcp_range_start,$aDhcp_range_end,$aDhcp_time
EOF
sudo mv -vn /etc/dnsmasq.d/*.conf /tmp/dnsmasq.d/
sudo mv /tmp/custom-dnsmasq.conf /etc/dnsmasq.d/custom-dnsmasq.conf
sudo systemctl start dnsmasq

# Show off what we did
sudo iptables-save | grep --no-group-separator -e '^-A' -e '^*' | grep -ve '^#'

#################
# End Of Code
#################
#
# The iptables language:
#
#   iptables understands ipv4 (ip6tables understand ipv6 (not used))
#   apt-get install iptables # comes preinstalled with debian
#
#   An iptable stores a chain of rules which redirects packets.
#     The first match in a chain determines the packet destination. 
#   The iptables table name determines when and how the table is used.
#     An iptables name is not random or arbitrary.
#       
#   --table 'filter' is the default and is for firewall creation
#   --table 'mangle' is for chaning packet headers (TTL values...)
#   --table 'nat' is for routing packets to different hosts via Network Address Translation
#   --table 'raw' is a stateful firewall (knows if packet is part of a new or existing connection...)
#       
#   Chains of a table determine the inspection point.
#     PREROUTING chain is for arriving packets in tables 'nat', 'mangle' and 'raw'.
#     INPUT is chain for packets going to local process in tables 'mangle' and 'filter'.
#     OUTPUT is chain for packets from a process in tables 'raw', 'mangle', 'nat', and 'filter'.
#     FORWARD is chain for packets routed through localhost in tables 'mangle', 'filter'.
#     POSTROUTING is chain for exiting packets in tables 'nat', 'mangle'.
#     MASQUERADE chain...
#       When it receives a datagram from a computer on the LAN
#         it takes note of the type of datagram it is, "TCP," "UDP," "ICMP," etc.
#         and modifies the datagram so that it looks like it was generated by the router machine itself
#         and remembers that it has done so.
#       It then transmits the datagram onto the Internet with its single connected IP address.
#       When the destination host receives this datagram,
#         it believes the datagram has come from the routing host and sends any reply datagrams back to that address.
#       When the Linux masquerade router receives a datagram from its Internet connection,
#         it looks in its table of established masqueraded connections
#         to see if this datagram actually belongs to a computer on the LAN,
#         if it does, it reverses the modification it did on the forward path
#         and transmits the datagram to the LAN computer.
#       
#   The target of a rule defines what happens to matched packets.
#     ACCEPT is the default which forwards or allows the packet.
#     DROP acts as if the packet did not exist.
#     REJECT responds with an error (then drop).
#     LOG creates a kernel log entry (in /var/log/syslog or /var/log/messesages) (then drop).
#       
# The iptables interface:
#
#   sudo iptables
#     -L|--list -v|--verbose list current ip table entries (no --table shows filter table)
#     -F|--flush empty all ip table entries (no --table flushes filter table)
#     -A|--append creates a new rule
#     -j|--jump where to send the packet if the packet matches the rule
#     -i|--in-interface where packet must come for for a match
#     -o|--out-interface where packet must be going to for for a match
#     -m|--match state list,of,states allowed or a match
#     note: see man iptables for many other types of matching rules
#       
#   Packets have a state:
#     NEW for the very first packet of a connection
#     ESTABLISHED for packets that are part of an existing connection
#     RELATED for packets related to another established connection (ftp)
#     INVALID for packets whose state is unknown or improper
#     UNTRACKED for packets specifically exempted from connection tracking
#     DNAT for packets whose destination address was changed by the table
#     SNAT for packets whose source address was changed by the table
#       
#   Anything you block on the INPUT chain, you canâ€™t access either.
#      --state RELATED,ESTABLISHED --jump ACCEPT declares "allow existing connections to continue"
#
# Save/restore iptables:
#   Once declared, iptables may be saved and restored to/from files of your choice.
#   $ sudo iptables-save > iptables.rules # write current rules to configuration file
#   $ sudo iptables-restore < iptables.rules # restore rules from configuration file
#   $ sudo apt-get install iptables-persistent # package for automated iptables-save/restore